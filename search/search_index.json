{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to my personal blog, where I share my journey and insights into the world of programming. Here, you'll find posts about <code>Python</code>, <code>Dart</code>, <code>Flutter</code>, <code>Swift</code>, <code>SwiftUI</code>, <code>Linux</code>, and everything that fuels my passion for code. Whether you're here to learn, explore, or connect, I hope you find inspiration in these pages.</p> <ul> <li> Swift</li> </ul>"},{"location":"swift/","title":"Swift","text":"<p>Swift is a general-purpose programming language developed by Apple Inc. for iOS, macOS, watchOS, and tvOS. It is designed to be safe, fast, and expressive, with features such as optionals, error handling, generics, and closures.</p> <ul> <li> Extensions in Swift</li> </ul>"},{"location":"swift/continued-learning/extensions-in-swift/","title":"Extensions in Swift","text":"<p><code>Extensions</code> in Swift allow us to add new functionality to existing <code>Classes</code>, <code>Structures</code>, <code>Enumerations</code>, or <code>Protocol</code> types. This includes adding new methods, properties, initializers, and more. Extensions are particularly useful for organizing and modularizing our code without needing to modify the original type, especially when we don't have access to the original source code.</p>"},{"location":"swift/continued-learning/extensions-in-swift/#extension-syntax","title":"Extension syntax","text":"<p>To create an extension, we use the <code>extension</code> keyword followed by the name of the type we want to extend.</p> <pre><code>extension SomeType {\n    // New functionalities to be added\n}\n</code></pre> <p>Let's explore some practical examples to understand how extensions work in Swift.</p>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-custom-functionality-to-existing-types","title":"Adding custom functionality to existing types","text":""},{"location":"swift/continued-learning/extensions-in-swift/#adding-computed-properties","title":"Adding computed properties","text":"<p>Extensions allow us to add computed properties. For example, we can add a computed property that determines if an integer is even or odd.</p> <pre><code>extension Int {\n    var isEven: Bool {\n        self % 2 == 0\n    }\n}\n\nprint(4.isEven) // Outputs: true\nprint(7.isEven) // Outputs: false\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-methods","title":"Adding Methods","text":"<p>Suppose we have a <code>String</code> type and want to add a method that reverses the string. Instead of modifying the <code>String</code> type itself, we can create an extension that adds a new method.</p> <pre><code>extension String {\n    func reverse() -&gt; String {\n        String(self.reversed())\n    }\n}\n\nprint(\"abc\".reverse()) // Outputs: cba\n</code></pre> <p>If a method needs to modify (or mutate) the instance itself, we need to mark the method as <code>mutating</code>. The example below adds a new mutating method called square to Swift\u2019s Int type, which squares the original value.</p> <pre><code>extension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\n\nvar number = 5\nnumber.square()\nprint(number) // Outputs: 25\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-initializers","title":"Adding Initializers","text":"<p>Extensions can also provide additional initializers. For example, we can add an initializer that creates a <code>Date</code> instance from a timestamp.</p> <pre><code>extension Date {\n    init?(timestamp: Double) {\n        self.init(timeIntervalSince1970: timestamp)\n    }\n}\n\nlet timestamp = 1693982400.0 // Unix timestamp for 2023-09-06 06:40:00\nif let date = Date(timestamp: timestamp) {\n    print(date) // Outputs: 2023-09-06 06:40:00 +0000\n}\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-subscripts","title":"Adding Subscripts","text":"<p>Extensions can add new subscripts to an existing type. For example, we can add a subscript that returns the character at a given index in the string.</p> <pre><code>extension String {\n    subscript(index: Int) -&gt; Character {\n        self[self.index(startIndex, offsetBy: index)]\n    }\n}\n\nprint(\"Swift\"[1]) // Outputs: w\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-functionality-to-custom-types","title":"Adding functionality to custom types","text":""},{"location":"swift/continued-learning/extensions-in-swift/#adding-computed-properties_1","title":"Adding computed properties","text":"<p>We can also add computed properties to a type using extensions. For instance, for the <code>Person</code> class, we might add a computed property that determines if the person is an adult.</p> <pre><code>class Person {\n    var name: String\n    var age: Int\n\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nextension Person {\n    var isAdult: Bool {\n        return age &gt;= 18\n    }\n}\n\nprint(person.isAdult) // Outputs: true\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-methods_1","title":"Adding methods","text":"<p>Suppose we have a <code>Circle</code> class and want to add a method that calculates the area of the circle. We can do this using extensions.</p> <pre><code>class Circle {\n    var radius: Double\n\n    init(radius: Double) {\n        self.radius = radius\n    }\n}\n\nextension Circle {\n    func area() -&gt; Double {\n        return 3.14 * radius * radius\n    }\n}\n\nlet circle = Circle(radius: 5.0)\nprint(circle.area()) // Outputs: 78.5\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#constraints-for-extensions","title":"Constraints for extensions","text":"<p>Constraints on extensions in Swift allow us to extend a type only when it meets certain conditions. This is especially useful when we want to add functionality to a type that conforms to a specific protocol or has certain properties.</p> <p>In the example below, we will create an extension on Array that only works when the elements of the array conform to the Numeric protocol. We will add a method called sum() that calculates the sum of the elements in the array.</p> <pre><code>extension Array where Element: Numeric {\n    func sum() -&gt; Element {\n        reduce(0, +)\n    }\n}\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.sum()) // Outputs: 15\n\nlet doubles = [1.5, 2.5, 3.5]\nprint(doubles.sum()) // Outputs: 7.5\n\n// This will not work because String is not Numeric\n// let strings = [\"a\", \"b\", \"c\"]\n// print(strings.sum())\n// Error: Cannot invoke 'sum' with an array of strings\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#protocol-extensions","title":"Protocol extensions","text":"<p>In Swift, we can also extend protocols. It works pretty much like abstract classes when regarding a functionality we want to be available in all the classes that implements some protocol (without having to inherit from a base common class).</p> <pre><code>// Define a protocol\nprotocol Describable {\n    func describe() -&gt; String\n}\n\n// Provide a default implementation using a protocol extension\nextension Describable {\n    func describe() -&gt; String {\n        \"This is a generic description\"\n    }\n}\n\n// Define a struct that conforms Describable protocol\nstruct Person: Describable {\n    var name: String\n    var age: Int\n\n    // Overriding the default implementation\n    func describe() -&gt; String {\n        \"My name is \\(name) and I am \\(age) years old.\"\n    }\n}\n\nstruct Employee: Describable {\n    var name: String\n    var age: Int\n\n    // Using the default implementation\n}\n\n// By just implementing the protocol the describe() method is available\n\nlet person = Person(name: \"Ivan\", age: 21)\nlet employee = Employee(name: \"Saul\", age: 25)\n\nprint(person.describe()) // Outputs: My name is Ivan and I am 21 years old.\nprint(employee.describe()) // Outputs: This is a generic description\n</code></pre>"}]}